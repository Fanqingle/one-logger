package fun.pxyc.onelogger.db;

import com.alibaba.druid.filter.FilterAdapter;
import com.alibaba.druid.filter.FilterChain;
import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.pool.DruidPooledConnection;
import com.alibaba.druid.proxy.jdbc.*;
import com.alibaba.druid.sql.SQLUtils;
import fun.pxyc.onelogger.auditlog.AsyncAuditLog;
import fun.pxyc.onelogger.autoconfig.EnvConfigProps;
import fun.pxyc.onelogger.trace.Span;
import fun.pxyc.onelogger.trace.Trace;
import fun.pxyc.onelogger.trace.TraceContext;
import fun.pxyc.onelogger.trace.TraceData;
import java.sql.Connection;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DruidAuditLogFilter extends FilterAdapter {
    private static final Logger log = LoggerFactory.getLogger(DruidAuditLogFilter.class);
    private static final SQLUtils.FormatOption DEFAULT_FORMAT_OPTION = new SQLUtils.FormatOption(true, true);
    private static final ThreadLocal<AuditInfo> thAuditInfo = new ThreadLocal();
    private final AtomicInteger seq = new AtomicInteger(0);

    public DruidAuditLogFilter() {}

    boolean isLevelOne() {
        AuditInfo auditInfo = thAuditInfo.get();
        return auditInfo != null && auditInfo.tranLevel == 1;
    }

    public DruidPooledConnection dataSource_getConnection(
            FilterChain chain, DruidDataSource dataSource, long maxWaitMillis) throws SQLException {
        AuditInfo auditInfo = thAuditInfo.get();
        if (auditInfo != null) {
            ++auditInfo.tranLevel;
            return super.dataSource_getConnection(chain, dataSource, maxWaitMillis);
        } else {
            Span span = Trace.startAsync("DB", "TRANS");
            auditInfo = new AuditInfo(span);
            thAuditInfo.set(auditInfo);

            try {
                return super.dataSource_getConnection(chain, dataSource, maxWaitMillis);
            } catch (SQLException exception) {
                span.stop(false);
                thAuditInfo.remove();
                throw exception;
            }
        }
    }

    public void dataSource_releaseConnection(FilterChain chain, DruidPooledConnection connection) throws SQLException {
        SQLException th = null;

        try {
            super.dataSource_releaseConnection(chain, connection);
        } catch (SQLException exception) {
            th = exception;
        }

        AuditInfo auditInfo = thAuditInfo.get();
        if (auditInfo == null) {
            if (th != null) {
                throw th;
            }
        } else if (auditInfo.tranLevel >= 2) {
            --auditInfo.tranLevel;
            if (th != null) {
                throw th;
            }
        } else {
            auditInfo.span.stop(th == null);
            this.finalLog(Trace.currentContext(), auditInfo.span);
            thAuditInfo.remove();
            if (th != null) {
                throw th;
            }
        }
    }

    public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql)
            throws SQLException {
        return super.connection_prepareStatement(chain, connection, sql);
    }

    public PreparedStatementProxy connection_prepareStatement(
            FilterChain chain, ConnectionProxy connection, String sql, int autoGeneratedKeys) throws SQLException {
        return super.connection_prepareStatement(chain, connection, sql, autoGeneratedKeys);
    }

    public PreparedStatementProxy connection_prepareStatement(
            FilterChain chain, ConnectionProxy connection, String sql, int resultSetType, int resultSetConcurrency)
            throws SQLException {
        return super.connection_prepareStatement(chain, connection, sql, resultSetType, resultSetConcurrency);
    }

    public PreparedStatementProxy connection_prepareStatement(
            FilterChain chain,
            ConnectionProxy connection,
            String sql,
            int resultSetType,
            int resultSetConcurrency,
            int resultSetHoldability)
            throws SQLException {

        return super.connection_prepareStatement(
                chain, connection, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    public PreparedStatementProxy connection_prepareStatement(
            FilterChain chain, ConnectionProxy connection, String sql, int[] columnIndexes) throws SQLException {

        return super.connection_prepareStatement(chain, connection, sql, columnIndexes);
    }

    public PreparedStatementProxy connection_prepareStatement(
            FilterChain chain, ConnectionProxy connection, String sql, String[] columnNames) throws SQLException {

        return super.connection_prepareStatement(chain, connection, sql, columnNames);
    }

    public boolean preparedStatement_execute(FilterChain chain, PreparedStatementProxy statement) throws SQLException {
        if (!this.isLevelOne()) {
            return super.preparedStatement_execute(chain, statement);
        } else {
            String sql = statement.getSql();
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                boolean firstResult = super.preparedStatement_execute(chain, statement);
                span.stop(true);
                this.log(span, statement, statement.getSql(), this.getRowCount(firstResult, statement), null);
                return firstResult;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, statement.getSql(), "", exception);
                throw exception;
            }
        }
    }

    public ResultSetProxy preparedStatement_executeQuery(FilterChain chain, PreparedStatementProxy statement)
            throws SQLException {
        if (!this.isLevelOne()) {
            return super.preparedStatement_executeQuery(chain, statement);
        } else {
            String sql = statement.getSql();
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                ResultSetProxy res = super.preparedStatement_executeQuery(chain, statement);
                span.stop(true);
                this.log(span, statement, statement.getSql(), "", null);
                return res;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, statement.getSql(), "", exception);
                throw exception;
            }
        }
    }

    public int preparedStatement_executeUpdate(FilterChain chain, PreparedStatementProxy statement)
            throws SQLException {
        if (!this.isLevelOne()) {
            return super.preparedStatement_executeUpdate(chain, statement);
        } else {
            String sql = statement.getSql();
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                int n = super.preparedStatement_executeUpdate(chain, statement);
                span.stop(true);
                this.log(span, statement, statement.getSql(), String.valueOf(n), null);
                return n;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, statement.getSql(), "", exception);
                throw exception;
            }
        }
    }

    public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql) throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_execute(chain, statement, sql);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                boolean firstResult = super.statement_execute(chain, statement, sql);
                span.stop(true);
                this.log(span, statement, sql, this.getRowCount(firstResult, statement), null);
                return firstResult;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, int autoGeneratedKeys)
            throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_execute(chain, statement, sql, autoGeneratedKeys);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                boolean firstResult = super.statement_execute(chain, statement, sql, autoGeneratedKeys);
                span.stop(true);
                this.log(span, statement, sql, this.getRowCount(firstResult, statement), null);
                return firstResult;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, int[] columnIndexes)
            throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_execute(chain, statement, sql, columnIndexes);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                boolean firstResult = super.statement_execute(chain, statement, sql, columnIndexes);
                span.stop(true);
                this.log(span, statement, sql, this.getRowCount(firstResult, statement), null);
                return firstResult;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public boolean statement_execute(FilterChain chain, StatementProxy statement, String sql, String[] columnNames)
            throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_execute(chain, statement, sql, columnNames);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                boolean firstResult = super.statement_execute(chain, statement, sql, columnNames);
                span.stop(true);
                this.log(span, statement, sql, this.getRowCount(firstResult, statement), null);
                return firstResult;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "`", exception);
                throw exception;
            }
        }
    }

    public void statement_addBatch(FilterChain chain, StatementProxy statement, String sql) throws SQLException {

        super.statement_addBatch(chain, statement, sql);
    }

    public int[] statement_executeBatch(FilterChain chain, StatementProxy statement) throws SQLException {
        if (!this.isLevelOne()) {
            return super.statement_executeBatch(chain, statement);
        } else {
            String sql = statement.getBatchSql();

            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                int[] rowCounts = super.statement_executeBatch(chain, statement);
                span.stop(true);
                this.log(span, statement, sql, this.rowCountsToStr(rowCounts), null);
                return rowCounts;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public ResultSetProxy statement_executeQuery(FilterChain chain, StatementProxy statement, String sql)
            throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_executeQuery(chain, statement, sql);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                ResultSetProxy res = super.statement_executeQuery(chain, statement, sql);
                span.stop(true);
                this.log(span, statement, sql, "", null);
                return res;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql) throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_executeUpdate(chain, statement, sql);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                int n = super.statement_executeUpdate(chain, statement, sql);
                span.stop(true);
                this.log(span, statement, sql, String.valueOf(n), null);
                return n;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql, int autoGeneratedKeys)
            throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_executeUpdate(chain, statement, sql, autoGeneratedKeys);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                int n = super.statement_executeUpdate(chain, statement, sql, autoGeneratedKeys);
                span.stop(true);
                this.log(span, statement, sql, String.valueOf(n), null);
                return n;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql, int[] columnIndexes)
            throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_executeUpdate(chain, statement, sql, columnIndexes);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                int n = super.statement_executeUpdate(chain, statement, sql, columnIndexes);
                span.stop(true);
                this.log(span, statement, sql, String.valueOf(n), null);
                return n;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public int statement_executeUpdate(FilterChain chain, StatementProxy statement, String sql, String[] columnNames)
            throws SQLException {

        if (!this.isLevelOne()) {
            return super.statement_executeUpdate(chain, statement, sql, columnNames);
        } else {
            Span span = thAuditInfo.get().span.newChild("DB", this.parseAction(sql));

            try {
                int n = super.statement_executeUpdate(chain, statement, sql, columnNames);
                span.stop(true);
                this.log(span, statement, sql, String.valueOf(n), null);
                return n;
            } catch (SQLException exception) {
                span.stop(false);
                this.log(span, statement, sql, "", exception);
                throw exception;
            }
        }
    }

    public boolean resultSet_next(FilterChain chain, ResultSetProxy resultSet) throws SQLException {
        if (!this.isLevelOne()) {
            return super.resultSet_next(chain, resultSet);
        } else {
            boolean ok = super.resultSet_next(chain, resultSet);
            if (ok && resultSet.getCursorIndex() == 0) {
                try {
                    if ("select 1".equals(resultSet.getSql())) {
                        return ok;
                    }

                    if (!AsyncAuditLog.isDbEnabled()) {
                        return ok;
                    }

                    List<SqlInfo> list = thAuditInfo.get().tranInfo;
                    if (list == null || list.size() == 0) {
                        return ok;
                    }

                    SqlInfo info = list.get(list.size() - 1);
                    info.resParams = "data:" + this.curRowData(resultSet);
                } catch (Exception exception) {
                    log.error("next result exception");
                }
            }

            return ok;
        }
    }

    String curRowData(ResultSetProxy resultSet) throws SQLException {
        StringBuilder buf = new StringBuilder();
        ResultSetMetaData meta = resultSet.getMetaData();
        int i = 0;

        for (int size = meta.getColumnCount(); i < size; ++i) {
            if (i != 0) {
                buf.append(",");
            }

            int columnIndex = i + 1;
            int type = meta.getColumnType(columnIndex);
            Object value;
            if (type == 93) {
                value = resultSet.getTimestamp(columnIndex);
            } else if (type == 2004) {
                value = "<BLOB>";
            } else if (type == 2005) {
                value = "<CLOB>";
            } else if (type == 2011) {
                value = "<NCLOB>";
            } else if (type == -2) {
                value = "<BINARY>";
            } else {
                value = resultSet.getObject(columnIndex);
            }

            buf.append(AsyncAuditLog.toTextAndEscape(value, EnvConfigProps.dbLogMaxChars));
        }

        return buf.toString();
    }

    public void resultSet_close(FilterChain chain, ResultSetProxy resultSet) throws SQLException {
        if (!this.isLevelOne()) {
            super.resultSet_close(chain, resultSet);
        } else {
            super.resultSet_close(chain, resultSet);

            try {
                if ("select 1".equals(resultSet.getSql())) {
                    return;
                }

                if (!AsyncAuditLog.isDbEnabled()) {
                    return;
                }

                String rc = String.valueOf(resultSet.getFetchRowCount());
                List<SqlInfo> list = thAuditInfo.get().tranInfo;
                if (list.size() == 0) {
                    return;
                }

                SqlInfo info = list.get(list.size() - 1);
                info.stopMicros = System.nanoTime() / 1000L;
                if (info.resParams.isEmpty()) {
                    info.resParams = "rowCount:" + rc;
                } else {
                    info.resParams = "rowCount:" + rc + "^" + info.resParams;
                }
            } catch (Exception exception) {
                log.error("close result set exception", exception);
            }
        }
    }

    private void finalLog(TraceContext ctx, Span span) {
        try {
            this.finalLogInternal(ctx, span);
        } catch (Throwable throwable) {
            log.error("finalLogInternal exception", throwable);
        }
    }

    private void finalLogInternal(TraceContext ctx, Span span) {
        TraceData trace = ctx.getTrace();
        String traceId = trace.getTraceId();
        String connId = "0.0.0.0:0:0";
        List<SqlInfo> list = thAuditInfo.get().tranInfo;
        if (list.size() > 0) {
            SqlInfo first = list.get(0);
            connId = first.connId;
            first.startMicros = span.getStartMicros();
            SqlInfo last = list.get(list.size() - 1);
            last.stopMicros = span.getStartMicros() + span.getTimeUsedMicros();
        }

        boolean logEnabled = AsyncAuditLog.isDbEnabled();
        Iterator exception4 = list.iterator();

        while (exception4.hasNext()) {
            SqlInfo info = (SqlInfo) exception4.next();
            long duration = info.stopMicros - info.startMicros;
            String msgName = info.msgName;
            info.span.changeAction(msgName);
            if (duration >= EnvConfigProps.slowSqlMillis * 1000L) {
                log.warn(
                        "slow sql:" + AsyncAuditLog.escapeText(info.sql) + ", ts=" + duration + ", traceId=" + traceId);
            }

            if (logEnabled) {
                String serviceNameMsgName = "DB." + msgName;

                String extraInfo = "db:" + info.dbName;
                if (list.size() > 1) {
                    extraInfo = extraInfo + "^trans:" + span.getSpanId();
                }

                String timestamp = AsyncAuditLog.now(ctx, info.stopMicros);
                String b = timestamp + ",   " + traceId
                        + ",   " + info.span.getSpanId()
                        + ",   " + info.span.getRootSpan().getAction()
                        + ",   " + connId
                        + ",   " + serviceNameMsgName
                        + ",   " + info.sequence
                        + ",   " + duration / 1000
                        + "ms,   " + info.reqParams
                        + ",   " + info.resParams
                        + ",   " + extraInfo;
                AsyncAuditLog.logDb(b);
            }
        }
    }

    String getRowCount(boolean firstResult, StatementProxy statement) throws SQLException {
        return firstResult ? "" : String.valueOf(statement.getUpdateCount());
    }

    String rowCountsToStr(int[] rowCounts) {
        if (rowCounts == null) {
            return "";
        } else {
            StringBuilder b = new StringBuilder();

            for (int i = 0; i < rowCounts.length; ++i) {
                int rowCount = rowCounts[i];
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(rowCount);
            }

            return b.toString();
        }
    }

    private void log(Span span, StatementProxy statement, String sql, String rc, SQLException throwable) {
        try {
            this.logInternal(span, statement, sql, rc, throwable);
        } catch (Throwable t) {
            log.error("logInternal exception", t);
        }
    }

    private void logInternal(Span span, StatementProxy statement, String sql, String rc, SQLException throwable) {
        if (!"select 1".equals(sql)) {
            SqlInfo sqlInfo = new SqlInfo();
            sqlInfo.sql = sql;
            sqlInfo.startMicros = span.getStartMicros();
            sqlInfo.stopMicros = span.getStartMicros() + span.getTimeUsedMicros();
            if (!AsyncAuditLog.isDbEnabled()) {
                List<SqlInfo> list = thAuditInfo.get().tranInfo;
                list.add(sqlInfo);
            } else {
                int sequence = this.seq.incrementAndGet();
                if (sequence >= 10000000) {
                    this.seq.compareAndSet(sequence, 0);
                }

                sqlInfo.sequence = sequence;
                sqlInfo.span = span;
                String msgName = DbMsgNameHolder.msgName.get();
                if (msgName == null || msgName.startsWith("jdbc_")) {
                    msgName = this.parseMsgName(sql, msgName);
                }

                sqlInfo.msgName = msgName;
                sqlInfo.dbName = this.genDbName(statement);
                sqlInfo.e = throwable;
                sqlInfo.reqParams = this.genReqParams(statement, sql);
                sqlInfo.resParams = this.genResParams(statement, sql, rc, throwable);
                List<SqlInfo> list = thAuditInfo.get().tranInfo;
                if (list.size() == 0) {
                    sqlInfo.connId = this.genConnId(statement);
                }

                list.add(sqlInfo);
            }
        }
    }

    String genConnId(StatementProxy statement) {
        Connection conn = statement.getConnectionProxy().getRawObject();
        return DbInstrument.getHostPort(conn);
    }

    String genDbName(StatementProxy statement) {
        Connection conn = statement.getConnectionProxy().getRawObject();
        return DbInstrument.getDatabase(conn);
    }

    String genReqParams(StatementProxy statement, String sql) {
        String s = AsyncAuditLog.escapeText(this.formatSql(statement, sql), EnvConfigProps.dbLogMaxChars);
        return "sql:" + s;
    }

    String genResParams(StatementProxy statement, String sql, String rc, SQLException throwable) {
        if (throwable != null) {
            String s = AsyncAuditLog.escapeText(throwable.getMessage());
            return "sqlCode:" + throwable.getErrorCode() + "^exception:" + s;
        } else {
            try {
                return rc.isEmpty() ? "" : "rowCount:" + rc;
            } catch (Exception exception) {
                return "exception:" + AsyncAuditLog.escapeText(exception.getMessage());
            }
        }
    }

    String parseAction(String sql) {
        int p = sql.indexOf(" ");
        String action = p >= 0 ? sql.substring(0, p) : sql;
        if (action.length() > 7) {
            action = action.substring(0, 7);
        }

        return action.toLowerCase();
    }

    String parseMsgName(String sql, String oldMsgName) {
        String action = this.parseAction(sql);
        if (oldMsgName != null && oldMsgName.contains("batch")) {
            action = "batch" + action;
        }

        String tableName = this.getTableName(sql);
        return tableName + ".jdbc_" + action;
    }

    String getTableName(String sql) {
        return DbDyeing.undyeingTable(DbDyeing.findFirstTable(sql));
    }

    private String formatSql(StatementProxy statement, String sql) {
        int parametersSize = statement.getParametersSize();
        List<Object> parameters = new ArrayList(parametersSize);

        for (int i = 0; i < parametersSize; ++i) {
            JdbcParameter jdbcParam = statement.getParameter(i);
            parameters.add(jdbcParam != null ? jdbcParam.getValue() : null);
        }

        String dbType = statement.getConnectionProxy().getDirectDataSource().getDbType();
        return SQLUtils.format(sql, dbType, parameters, DEFAULT_FORMAT_OPTION);
    }

    static class SqlInfo {
        String sql;
        long startMicros;
        long stopMicros;
        int sequence;
        Span span;
        String msgName;
        String dbName;
        Throwable e;
        String reqParams;
        String resParams;
        String connId;

        SqlInfo() {}
    }

    static class AuditInfo {
        List<SqlInfo> tranInfo = new ArrayList();
        int tranLevel = 1;
        Span span;

        AuditInfo(Span span) {
            this.span = span;
        }
    }
}
